*********	COMANDOS POSTGRE_SQL	********



- Conocer todos los comandos y sus guias.
# \?

- Listar todas las bases de datos.
# \l

- Acceder a la bases de datos.
# \c <name_database>

- Listar todas las tablas.
# \dt

- Describir tablas.
# \d <name_table>

- Si necesitamos ayuda en algun comando que tengas en duda. Ver todas las funciones que podemos utilizar siendo comandos SQL.
# \h

- Si tenemos duda de como se utiliza alguna funcion.
# \h <name_funcion_comando>

- Que version esta ejecutando en la BD. (Verificar que es mejor poner los comandos de SQL en mayuscula)
# SELECT version();

- 2 Comandos utiles para encontrar cualquier problema con la interfaz grafica.
    (\g) te permite ejeuctar la ultima funcion que acabas de utilizar en la consola.
# \g
    
    (\timing) cuando queremos optimizar la BD, con esta funcion podemos inicializar el tiempo que en cada ejecucion cuanto se demoro en ejecutar ese comando.
# \timing  (podemos visualizar que en cada ejecucion aparece un tiempo 

-----------------------------------------------------------------------
ARCHIVOS DE CONFIGURACION 

- postgresql.conf
- pg_hba.conf
- pg_ident.conf

- Saber donde estan nuestros archivos de configuracion.
# SHOW config_file;
-----------------------------------------------------------------------
*** COMANDOS DE NAVEGACION & CONSULTA DE INFORMACION ***

- Listar los esquemas de la base de datos actual.
# \dn

- Listar las funciones disponibles de la base de datos actual.
# \df

- Listar las vistas de la base de datos actual.
# \dv

- Listar los usuarios y sus roles de la base de datos actual.
# \du
-----------------------------------------------------------------------
*** COMANDOS DE INSPECCION Y EJECUCION ***

-  Volver a ejecutar el comando ejecutado justo antes.
# \g

-  Ver el historial de comandos ejecutados.
# \s

- Si se quiere guardar la lista de comandos ejecutados en un archivo de texto plano.
# \s <nombre_archivo>

- Ejecutar los comandos desde un archivo.
# \i <name_archivo>

- Permite abrir un editor de texto plano, escribir comomandos y ejecutar en lote. \e abre el editor de texto, escribir allí todos los comandos, luego guardar los cambios y cerrar, al cerrar se ejecutarán todos los comandos guardados.
# \e

- Equivalente al comando anterior pero permite editar tambien funciones de PostgreSQL.
# \ef
-----------------------------------------------------------------------
***  COMANDOS PARA DEBUG Y OPTIMIZACIÓN  ***

- Activar / Desactivar el contador de tiempo por consulta.
# \timing

-----------------------------------------------------------------------
***  COMANDOS PARA CERRAR LA CONSOLA  ***

- Cerrar la consola.
# \q

-----------------------------------------------------------------------
***  COMANDOS BASICOS DE CRUD  ***

- Crear BB.
# CREATE DATABASE <name_new_db>;

- Crear table.
# CREATE TABLE <name_new_table> (name_columns VALOR);

- INSERCION DE DATOS.
# INSERT INTO <name_table> (<name_column>, <name_column>) VALUES (<'valor_column1'>, <valor_column2>);

- Consultamos ahora los datos en la tabla:
# SELECT * FROM <name_table>;

- Modificar valor.
# UPDATE <name_table> SET <name_column> = <new_value> WHERE <name_column> = <valor_correspondiente>;

- BORRAR REGISTRO.
# DELETE FROM <name_table> WHERE <condicion>;

- Realizar encriptacion de un texto usando el algoritmo md5.
# SELECT MD5 ('Vamos a encriptar este texto que leo');
-----------------------------------------------------------------------
***  TIPOS DE DATOS ***

Numericos
Monetarios
Texto
Binarios
Fecha / Hora
Boolean

- Formatos especiales de PostgreSQL
Geometricos
Direccion de Red
Texto tipo bit
XML,json
Arreglos
-----------------------------------------------------------------------
*** ROLES en la BD ***

Los roles como cualquier objeto de la BD tiene la capacidad de ser
creador o eliminados, sin embargo los roles tienen una caracteristica
especial y es que pueden crear o eliminar otros roles, tienen atributos
quiere decir que pueden hacer login o no, pueden acceder a la BD, pueden
eliminar tablas, los roles pueden ser agrupados bajo un conjunto global
de permisos y los roles existen de manera predeterminada en postgres.

(Los roles son independientes a las BD)

- Consulta para crear un Role.
# CREATE ROLE <name_rol> caracteristicas;

- Ver todas las funciones de CREATE ROLE.
# \h CREATE ROLE

- Vamos a crear un rol con la capacidad de hacer login y asignar la contraseña. (este usuario va a tener acceso de lectura, insertar y actualizar consulta.
# CREATE ROLE usuario_consulta; (asi lo creamos sin contraseña y con las caracteristicas predeterminadas y heredadas del padre)

- Ver todos los usuarios creados.
# \dg

- Ahora queremos que este rol tenga la capacidad de acceder a la BD, asi que lo tenemos que modificar.
# ALTER ROLE usuario_consulta WITH LOGIN;

- Ahora que tenga la capacidad de ser superusuario.
# ALTER ROLE usuario_consulta WITH SUPERUSER;

- Tenemos que agregarle a nuestro usuario contraseña para que el pueda acceder a la BD.
# ALTER ROLE <name_role> WITH PASSWORD '<contraseña en comillas simples'>;

- Borrar usuarios
(Para eliminar usuarios tenemos que cerrar la sesion que tenemos abierta y, iniciamos desde la sesion de postgres
# DROP ROLE <name_role>;

- CAMBIAR NOMBRE DEL USUARIO.
# ALTER ROLE <name_user> RENAME TO <new_name_role>;
-----------------------------------------------------------------------
***	LLAVES FORANEAS   ***

Se refiere a la relacion que tiene entre las tablas y corresponde con 
nuestro acid en la parte de consistencia, es decir, que todas la tablas
tienen relacion entre si y la inforacion es congruente.

Las llaves foraneas tienen una estructura basica, desde una tabla de origen
una tabla de destino y las acciones de que haya una modificacion en la tabla
de origen.

Para hacerlo nos dirigimos a pgadmin4 y ya teniendo toda la estructura
de la DB con tablas hechas nos dirigimos a la tabla que queremos relacionar,
vamos a propiedades, vamos a la pestaña constraints y donde dice foreign key
creamos el nombre de la Foreign key (por llevar un orden, nombramos primero
la tabla de origen y luego la tabla de destino y le agregamos el _fkey)
luego nos dirigimos a editar esa llave foranea (a mano izquierda aparece
un icono con un lapiz).

Al darle clic podemos obervar el nombre que le hemos puesto y en la columna
de definicion podemos agregar caracteristicas especiales, ya que podemos
que una llave foranea llegue ha ser validada al instante ó, sea validada
despues, o no sea validada cuando estemos haciendo un Backup, 
las caracteristicas que se nos muestran son (DEFERRABLE?); quiere decir 
que la podemos aplazar, (DEFERRED?); quiere decir que cuando la creemos 
no se va a validar, (MATCH TYPE?); quiere decir que la comparacion 
entre columnas va hacer valor a valor donde si tenemos algun parametro
diferente puede ser compleja, (VALIDATED?); quiere decir que tenemos que 
ser inicializar las tablas con la validacion, y (AUTO FK INDEX?); esta desavilitada de manera predeterminada por que no es un indice en nuestra tabla.

Ahora ya sabiendo esto miramos el caso que nos convenga, ahora nos 
dirigimos a la columna donde dice columns y donde dice local column hacemos
referencia con la columna que vaya hacer de origen (esta columna tiene
que ser el mismo valor que la columna referenciada) luego referenciamos
la tabla que queremos de destino y luego el identificador primario de
la columna de destino y, luego le damos al mas (+ ó ADD) que se encuentra en ese
mismo apartado, la pestaña accion es la mas importante ya que le decimos
que haga cuando haya un cambio.

- Si queremos hacer una consulta para agregar una llave foranea hacemos una
alteracion y luego agregamos la llave.
# ALTER TABLE <name_table> ADD CONSTRAINT <name_table_origin>_<name_table_destino>_fkey FOREIGN KEY (<name_column tabla origen>)
        REFERENCES public.<name_table_destino> (<name_column tabla destino>) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
        NOT VALID;

-----------------------------------------------------------------------
***	INSERCION DE DATOS	***

INSERT INTO public.<name_table>(
	name_column, name_column)
	VALUES ('Values', 'Values');

-----------------------------------------------------------------------
***	SELECT DE DATOS		***

SELECT * FROM public.<name_table>
ORDER BY id ASC;

-----------------------------------------------------------------------
***	DROP COLUMN	***

ALTER TABLE IF EXISTS public.<name_table> DROP COLUMN IF EXISTS <column>;

-----------------------------------------------------------------------
***	ADD COLUMN	***

ALTER TABLE IF EXISTS public.<name_table>
    ADD COLUMN <new_name_column> <type_values>;

-----------------------------------------------------------------------
***	BORRAR REGISTRO		***

DELETE FROM <name_table> WHERE <name_column> = <values>;

-----------------------------------------------------------------------
***	ACTUALIZACION DE REGISTRO	***

UPDATE public.<name_table>
	SET <name_column> = <new_value>, <name_column> = <new_value>, <name_column> = <new_value>
	WHERE <name_column> = <value_Before>;

-----------------------------------------------------------------------
***	JOINS	***

- Uniones sin JOIN
SELECT pasajero.id, pasajero.nombre, viaje.id_trayecto, viaje.inicio, viaje.fin
FROM pasajero, viaje
WHERE pasajero.id = viaje.id_pasajero ORDER BY pasajero.id ASC;

- QUe pasajeros an hecho almenos un viaje.
SELECT * FROM pasajero
JOIN viaje ON (viaje.id_pasajero = pasajero.id);

- Quienes no han tomado ni un solo viaje.
SELECT * FROM pasajero
LEFT JOIN viaje ON (viaje.id_pasajero = pasajero.id)
WHERE viaje.id IS NULL;

SELECT * FROM pasajero
RIGHT JOIN viaje ON viaje.id_pasajero = pasajero.id
ORDER BY pasajero.id ASC;

SELECT * FROM pasajero
LEFT JOIN viaje ON (viaje.id_pasajero = pasajero.id)
WHERE viaje.id ISNULL;


SELECT pasajero.id, pasajero.nombre, viaje.id_trayecto, viaje.inicio, viaje.fin
FROM pasajero, viaje
WHERE pasajero.id = viaje.id_pasajero ORDER BY pasajero.id ASC;

- Mostrar los pasajero que salgan desde la fecha '1987'

SELECT *  FROM pasajero
LEFT JOIN viaje 
	ON (viaje.id_pasajero = pasajero.id)
WHERE viaje.inicio >= '1987-01-01';

- Mostrar pasajeros que tengan un viaje desde tal fecha y terminan en tal fecha y ordernarlos por id de viaje .

SELECT * FROM viaje AS v
JOIN pasajero AS p ON p.id = v.id_pasajero
WHERE v.inicio >= '1996-01-01' AND v.fin <= '2010-01-01' AND nombre = 'Daniela A'
ORDER BY v.id ASC;

- Que trayectos van a tales estaciones.

SELECT * FROM trayecto AS t
JOIN estacion AS e
	ON (e.id = t.id_estacion);

- Que estacion tienen las rutas que contengan las letras de en alguna posicion.
SELECT * FROM estacion
LEFT JOIN trayecto 
	ON (estacion.id = trayecto.id)
WHERE estacion.nombre LIKE '%de%';

- Que estaciones no tienen ningun trayecto.
SELECT * FROM estacion
LEFT JOIN trayecto
	ON trayecto.id_estacion = estacion.id
WHERE trayecto.id_estacion ISNULL;

- Union de tren con trayecto.
SELECT * FROM tren
INNER JOIN trayecto
	ON trayecto.id_tren = tren.id;

- Mostrar los trenes que vayan con nombre de ruta 4.
SELECT * FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
WHERE trayecto.nombre = 'Ruta 4';
SELECT nombre FROM estacion;

- Mostrar los trenes que vayan con el trayecto empezando por la b 
(No comprendo por que la clausula LIKE no me deja encontrar con letras desde un inicio :/).

SELECT tren.id, tren.modelo, trayecto.id, trayecto.nombre FROM tren
LEFT JOIN trayecto
	ON trayecto.id_tren = tren.id
WHERE trayecto.nombre LIKE '_a%' 
ORDER BY tren.id, trayecto.nombre ASC 
LIMIT 10;

- Agrupar por trenes cuantos trayecto tienen cada tren (EStos toca corregirlos con logica).

SELECT tren.id, tren.modelo, SUM(trayecto.id) FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
GROUP BY trayecto.nombre;

SELECT tren.modelo, SUM(trayecto.id), trayecto.nombre FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
GROUP BY trayecto.nombre, tren.id;
