*********	COMANDOS POSTGRE_SQL	********



- Conocer todos los comandos y sus guias.
# \?

- Listar todas las bases de datos.
# \l

- Acceder a la bases de datos.
# \c <name_database>

- Listar todas las tablas.
# \dt

- Describir tablas.
# \d <name_table>

- Si necesitamos ayuda en algun comando que tengas en duda. Ver todas las funciones que podemos utilizar siendo comandos SQL.
# \h

- Si tenemos duda de como se utiliza alguna funcion.
# \h <name_funcion_comando>

- Que version esta ejecutando en la BD. (Verificar que es mejor poner los comandos de SQL en mayuscula)
# SELECT version();

- 2 Comandos utiles para encontrar cualquier problema con la interfaz grafica.
    (\g) te permite ejeuctar la ultima funcion que acabas de utilizar en la consola.
# \g
    
    (\timing) cuando queremos optimizar la BD, con esta funcion podemos inicializar el tiempo que en cada ejecucion cuanto se demoro en ejecutar ese comando.
# \timing  (podemos visualizar que en cada ejecucion aparece un tiempo 

-----------------------------------------------------------------------
ARCHIVOS DE CONFIGURACION 

- postgresql.conf
- pg_hba.conf
- pg_ident.conf

- Saber donde estan nuestros archivos de configuracion.
# SHOW config_file;
-----------------------------------------------------------------------
*** COMANDOS DE NAVEGACION & CONSULTA DE INFORMACION ***

- Listar los esquemas de la base de datos actual.
# \dn

- Listar las funciones disponibles de la base de datos actual.
# \df

- Listar las vistas de la base de datos actual.
# \dv

- Listar los usuarios y sus roles de la base de datos actual.
# \du
-----------------------------------------------------------------------
*** COMANDOS DE INSPECCION Y EJECUCION ***

-  Volver a ejecutar el comando ejecutado justo antes.
# \g

-  Ver el historial de comandos ejecutados.
# \s

- Si se quiere guardar la lista de comandos ejecutados en un archivo de texto plano.
# \s <nombre_archivo>

- Ejecutar los comandos desde un archivo.
# \i <name_archivo>

- Permite abrir un editor de texto plano, escribir comomandos y ejecutar en lote. \e abre el editor de texto, escribir allí todos los comandos, luego guardar los cambios y cerrar, al cerrar se ejecutarán todos los comandos guardados.
# \e

- Equivalente al comando anterior pero permite editar tambien funciones de PostgreSQL.
# \ef
-----------------------------------------------------------------------
***  COMANDOS PARA DEBUG Y OPTIMIZACIÓN  ***

- Activar / Desactivar el contador de tiempo por consulta.
# \timing

-----------------------------------------------------------------------
***  COMANDOS PARA CERRAR LA CONSOLA  ***

- Cerrar la consola.
# \q

-----------------------------------------------------------------------
***  COMANDOS BASICOS DE CRUD  ***

- Crear BB.
# CREATE DATABASE <name_new_db>;

- Crear table.
# CREATE TABLE <name_new_table> (name_columns VALOR);

- INSERCION DE DATOS.
# INSERT INTO <name_table> (<name_column>, <name_column>) VALUES (<'valor_column1'>, <valor_column2>);

- Consultamos ahora los datos en la tabla:
# SELECT * FROM <name_table>;

- Modificar valor.
# UPDATE <name_table> SET <name_column> = <new_value> WHERE <name_column> = <valor_correspondiente>;

- BORRAR REGISTRO.
# DELETE FROM <name_table> WHERE <condicion>;

- Realizar encriptacion de un texto usando el algoritmo md5.
# SELECT MD5 ('Vamos a encriptar este texto que leo');
-----------------------------------------------------------------------
***  TIPOS DE DATOS ***

Numericos
Monetarios
Texto
Binarios
Fecha / Hora
Boolean

- Formatos especiales de PostgreSQL
Geometricos
Direccion de Red
Texto tipo bit
XML,json
Arreglos
-----------------------------------------------------------------------
*** ROLES en la BD ***

Los roles como cualquier objeto de la BD tiene la capacidad de ser
creador o eliminados, sin embargo los roles tienen una caracteristica
especial y es que pueden crear o eliminar otros roles, tienen atributos
quiere decir que pueden hacer login o no, pueden acceder a la BD, pueden
eliminar tablas, los roles pueden ser agrupados bajo un conjunto global
de permisos y los roles existen de manera predeterminada en postgres.

(Los roles son independientes a las BD)

- Consulta para crear un Role.
# CREATE ROLE <name_rol> caracteristicas;

- Ver todas las funciones de CREATE ROLE.
# \h CREATE ROLE

- Vamos a crear un rol con la capacidad de hacer login y asignar la contraseña. (este usuario va a tener acceso de lectura, insertar y actualizar consulta.
# CREATE ROLE usuario_consulta; (asi lo creamos sin contraseña y con las caracteristicas predeterminadas y heredadas del padre)

- Ver todos los usuarios creados.
# \dg

- Ahora queremos que este rol tenga la capacidad de acceder a la BD, asi que lo tenemos que modificar.
# ALTER ROLE usuario_consulta WITH LOGIN;

- Ahora que tenga la capacidad de ser superusuario.
# ALTER ROLE usuario_consulta WITH SUPERUSER;

- Tenemos que agregarle a nuestro usuario contraseña para que el pueda acceder a la BD.
# ALTER ROLE <name_role> WITH PASSWORD '<contraseña en comillas simples'>;

- Borrar usuarios
(Para eliminar usuarios tenemos que cerrar la sesion que tenemos abierta y, iniciamos desde la sesion de postgres
# DROP ROLE <name_role>;

- CAMBIAR NOMBRE DEL USUARIO.
# ALTER ROLE <name_user> RENAME TO <new_name_role>;
-----------------------------------------------------------------------
***	LLAVES FORANEAS   ***

Se refiere a la relacion que tiene entre las tablas y corresponde con 
nuestro acid en la parte de consistencia, es decir, que todas la tablas
tienen relacion entre si y la inforacion es congruente.

Las llaves foraneas tienen una estructura basica, desde una tabla de origen
una tabla de destino y las acciones de que haya una modificacion en la tabla
de origen.

Para hacerlo nos dirigimos a pgadmin4 y ya teniendo toda la estructura
de la DB con tablas hechas nos dirigimos a la tabla que queremos relacionar,
vamos a propiedades, vamos a la pestaña constraints y donde dice foreign key
creamos el nombre de la Foreign key (por llevar un orden, nombramos primero
la tabla de origen y luego la tabla de destino y le agregamos el _fkey)
luego nos dirigimos a editar esa llave foranea (a mano izquierda aparece
un icono con un lapiz).

Al darle clic podemos obervar el nombre que le hemos puesto y en la columna
de definicion podemos agregar caracteristicas especiales, ya que podemos
que una llave foranea llegue ha ser validada al instante ó, sea validada
despues, o no sea validada cuando estemos haciendo un Backup, 
las caracteristicas que se nos muestran son (DEFERRABLE?); quiere decir 
que la podemos aplazar, (DEFERRED?); quiere decir que cuando la creemos 
no se va a validar, (MATCH TYPE?); quiere decir que la comparacion 
entre columnas va hacer valor a valor donde si tenemos algun parametro
diferente puede ser compleja, (VALIDATED?); quiere decir que tenemos que 
ser inicializar las tablas con la validacion, y (AUTO FK INDEX?); esta desavilitada de manera predeterminada por que no es un indice en nuestra tabla.

Ahora ya sabiendo esto miramos el caso que nos convenga, ahora nos 
dirigimos a la columna donde dice columns y donde dice local column hacemos
referencia con la columna que vaya hacer de origen (esta columna tiene
que ser el mismo valor que la columna referenciada) luego referenciamos
la tabla que queremos de destino y luego el identificador primario de
la columna de destino y, luego le damos al mas (+ ó ADD) que se encuentra en ese
mismo apartado, la pestaña accion es la mas importante ya que le decimos
que haga cuando haya un cambio.

- Si queremos hacer una consulta para agregar una llave foranea hacemos una
alteracion y luego agregamos la llave.
# ALTER TABLE <name_table> ADD CONSTRAINT <name_table_origin>_<name_table_destino>_fkey FOREIGN KEY (<name_column tabla origen>)
        REFERENCES public.<name_table_destino> (<name_column tabla destino>) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
        NOT VALID;

-----------------------------------------------------------------------
***	INSERCION DE DATOS	***

INSERT INTO public.<name_table>(
	name_column, name_column)
	VALUES ('Values', 'Values');

-----------------------------------------------------------------------
***	SELECT DE DATOS		***

SELECT * FROM public.<name_table>
ORDER BY id ASC;

-----------------------------------------------------------------------
***	DROP COLUMN	***

ALTER TABLE IF EXISTS public.<name_table> DROP COLUMN IF EXISTS <column>;

-----------------------------------------------------------------------
***	ADD COLUMN	***

ALTER TABLE IF EXISTS public.<name_table>
    ADD COLUMN <new_name_column> <type_values>;

-----------------------------------------------------------------------
***	BORRAR REGISTRO		***

DELETE FROM <name_table> WHERE <name_column> = <values>;

-----------------------------------------------------------------------
***	ACTUALIZACION DE REGISTRO	***

UPDATE public.<name_table>
	SET <name_column> = <new_value>, <name_column> = <new_value>, <name_column> = <new_value>
	WHERE <name_column> = <value_Before>;

-----------------------------------------------------------------------
***	JOINS	***

- Uniones sin JOIN
SELECT pasajero.id, pasajero.nombre, viaje.id_trayecto, viaje.inicio, viaje.fin
FROM pasajero, viaje
WHERE pasajero.id = viaje.id_pasajero ORDER BY pasajero.id ASC;

- QUe pasajeros an hecho almenos un viaje.
SELECT * FROM pasajero
JOIN viaje ON (viaje.id_pasajero = pasajero.id);

- Quienes no han tomado ni un solo viaje.
SELECT * FROM pasajero
LEFT JOIN viaje ON (viaje.id_pasajero = pasajero.id)
WHERE viaje.id IS NULL;

SELECT * FROM pasajero
RIGHT JOIN viaje ON viaje.id_pasajero = pasajero.id
ORDER BY pasajero.id ASC;




SELECT pasajero.id, pasajero.nombre, viaje.id_trayecto, viaje.inicio, viaje.fin
FROM pasajero, viaje
WHERE pasajero.id = viaje.id_pasajero ORDER BY pasajero.id ASC;

- Mostrar los pasajero que salgan desde la fecha '1987'

SELECT *  FROM pasajero
LEFT JOIN viaje 
	ON (viaje.id_pasajero = pasajero.id)
WHERE viaje.inicio >= '1987-01-01';

- Mostrar pasajeros que tengan un viaje desde tal fecha y terminan en tal fecha y ordernarlos por id de viaje .

SELECT * FROM viaje AS v
JOIN pasajero AS p ON p.id = v.id_pasajero
WHERE v.inicio >= '1996-01-01' AND v.fin <= '2010-01-01' AND nombre = 'Daniela A'
ORDER BY v.id ASC;

- Que trayectos van a tales estaciones.

SELECT * FROM trayecto AS t
JOIN estacion AS e
	ON (e.id = t.id_estacion);

- Que estacion tienen las rutas que contengan las letras de en alguna posicion.
SELECT * FROM estacion
LEFT JOIN trayecto 
	ON (estacion.id = trayecto.id)
WHERE estacion.nombre LIKE '%de%';

SELECT trayecto.id_estacion, estacion.nombre FROM trayecto
JOIN estacion
	ON trayecto.id_estacion = estacion.id
WHERE estacion.direccion LIKE '%o_d%'
GROUP BY trayecto.id_estacion, estacion.nombre
ORDER BY estacion.nombre DESC LIMIT 7;

- Que estaciones no tienen ningun trayecto.
SELECT * FROM estacion
LEFT JOIN trayecto
	ON trayecto.id_estacion = estacion.id
WHERE trayecto.id_estacion ISNULL;

- Union de tren con trayecto.
SELECT * FROM tren
INNER JOIN trayecto
	ON trayecto.id_tren = tren.id;

- Mostrar los trenes que vayan con nombre de ruta 4.
SELECT * FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
WHERE trayecto.nombre = 'Ruta 4';
SELECT nombre FROM estacion;

- Mostrar los trenes que vayan con el trayecto empezando por la b 
(No comprendo por que la clausula LIKE no me deja encontrar con letras desde un inicio :/).
(Al parecer el error es en que la clausula LIKE reconoce entre mayusculas
			 y minusculas y el comodin si es necesario).

SELECT tren.id FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
WHERE trayecto.nombre LIKE 'R%'
GROUP BY tren.id, trayecto.nombre
ORDER BY tren.id, trayecto.nombre ASC
LIMIT 10;

- Agrupar por trenes cuantos trayecto tienen cada tren (EStos toca corregirlos con logica).
(corregidos con instrucciones nuevas)
SELECT trayecto.nombre, tren.id FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
GROUP BY trayecto.nombre, tren.id;

SELECT tren.modelo, SUM(trayecto.id), trayecto.nombre FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
GROUP BY trayecto.nombre, tren.id;

- Agrupar todos los trenes por nombre y sumarles cada identificador que trenga relacionado con la tabla trayecto.
SELECT trayecto.nombre, SUM(tren.id + trayecto.id) FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
GROUP BY trayecto.nombre, tren.id;

--------------------------------------------------------
	Utilizando BETWEEN

SELECT tren.modelo, trayecto.id, trayecto.nombre FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
WHERE trayecto.id
BETWEEN 1 and 9;

--------------------------------------------------------
	MULTPLES JOINS
SELECT * FROM pasajero AS p
JOIN viaje as v
	ON v.id_pasajero = p.id
JOIN trayecto AS t
	ON v.id_trayecto = t.id
JOIN estacion AS e
	ON t.id_estacion = e.id
JOIN tren as tr
	ON t.id_tren = tr.id
WHERE p.id >= 1 AND p.id <77;

SELECT tren.id FROM tren
JOIN trayecto
	ON trayecto.id_tren = tren.id
WHERE trayecto.nombre LIKE 'R%'
GROUP BY tren.id, trayecto.nombre
ORDER BY tren.id, trayecto.nombre ASC
LIMIT 10;

---------------------------------------------------------
	FUNCIONES ESPECIALES PRINCIPALES

ON CONFLICT DO
RETURNING
LIKE / ILIKE
IS / IS NOT


- ON CONFLICT DO;
No ayuda a solucionar problemas cuando queremos insertar o 
modificar datos en una tabla que no podamos y justamente despues 
hacemos la actializacion correcta, es decir si queremos insertar 
un dato que ya existe ON CONFLICT DO nos permite insertar si lo 
que queremos es actualizar el mismo dato.

- Si no queremos hacer ningun cambio colocamos DO NOTHING
INSERT INTO public.estacion
	(id, nombre, direccion)
VALUES (1,'Kinekinesis','St 142 # 34')
	ON CONFLICT DO NOTHING;
	
- SI queremos hacer cambio indicamos la columna con conflicto
y luego hacemos una consulta update como cualquier otra
INSERT INTO public.estacion
	(id, nombre, direccion)
VALUES (1,'Kinekinesis','St 142 # 34')
	ON CONFLICT (id) DO UPDATE SET nombre = 'Kinekinesis', direccion = 'St 142 # 34';

- RETURNING;
Nos permite devolver todos los cambios que hemos echo en la BD.
INSERT INTO public.estacion
	(nombre, direccion)
VALUES ('Propegta','Zflek 15')
RETURNING *;

- LIKE / ILIKE
SELECT * FROM estacion
WHERE nombre ILIKE 'd_n%';

----------------------------------------------------------------
	FUNCIONES ESPECIALES AVANZADAS
COALESCE
NULLIF
GREATEST
LEAST
BLOQUES ANONIMOS


- COALESCE;
Te permite comparar dos valores y retornar cual de los dos
no es nul.

comparamos la columna que creemos que esta nula, si no esta nula
arroja el valor, si esta nula agregamos un mensaje en commilla simple.
SELECT id, COALESCE (nombre,'No aplica'), direccion_residencia, fecha_nacimiento
	FROM public.pasajero
WHERE id = 1;

Si no queremos que cambie el nombre de la columna le agregmos un alias.
SELECT id, COALESCE (nombre,'No aplica') AS name_table.


- NULLIF;
Tambien te permite retornar dos valores y
 retorna null si son iguales.

SELECT NULLIF (0,0);

- GREATEST Y LEAST;
Te permite comparar un arreglo de valores y te retorna
 en el caso de GREATEST el mayor y en el caso de LEAST el menor.
le pasamos un arreglo de valores y no muestra cual es el mayor.

SELECT GREATEST (0,2,4,5,6,7,8,9,0,32,55); # Retorna el valor mayor.
SELECT LEAST (0,2,4,5); # Retorna el valor menor

- BLOQUES ANONIMOS;
Al igual que el desarrollo de software te permite ingresar 
condicionales pero esta ves dentro de una consulta de BD.

SELECT id, nombre, direccion_residencia, fecha_nacimiento,
CASE
WHEN fecha_nacimiento > '1985-01-01' THEN
'Mayor'
ELSE
'Niño'
END
	FROM public.pasajero
WHERE fecha_nacimiento > '1985-01-01'
ORDER BY fecha_nacimiento ASC;

-- "SUPER CONSULTA"
SELECT p.id, p.nombre, p.fecha_nacimiento, v.inicio,tr.modelo, t.nombre, e.nombre,
CASE 
WHEN fecha_nacimiento > '1980-01-01' THEN 'Mayor'
ELSE 'Menor' END
FROM pasajero AS p
JOIN viaje AS v	ON v.id_pasajero = p.id
JOIN trayecto AS t ON t.id = v.id_trayecto
JOIN tren AS tr ON tr.id = t.id_tren
JOIN estacion AS e ON e.id = t.id_estacion
WHERE p.id >5 AND p.id < 142 AND p.nombre ILIKE 'd%'
ORDER BY fecha_nacimiento ASC;

------------------------------------------------------------------------
		VISTAS & VISTAS MATERIALIZADAS

Una vista en escencia es agarrar una consulta que repites
mucho y convertirla en un solo nombre, de modo que hagamos 
select * from <nam_vista>, a diferencia que hagamos 
select * from <name_table> ó JOINS, Porque? por que nos ayuda a centralizar
todos los esfuerzos en una funcion.

Tenemos dos opciones, VOLATILES Y MATERIALIZADAS.

Vista vs Vista Materializada

VOLATILES; Es que siempre que se haga consula a la vista la base datos va 
hacer la ejecucion a la BD por lo cual siempre tendremos informacion 
reciente.

MATERIALIZADAS; Solo hacemos la consulta 1 vez y esa informacion queda
almacenada en memoria, cuando hagamos una consulta nos traera lo que haya
en memoria

- llenar vista materializada para luego llamarla en la consulta;
# REFRESH MATERIALIZED VIEW <name_view_materialized;



SELECT * FROM inicio_fin_viaje_mview;
REFRESH MATERIALIZED VIEW inicio_fin_viaje_mview;

DELETE FROM viaje WHERE inicio >= '1996-01-03' AND fin = '1996-01-04'; 

SELECT * FROM viaje WHERE inicio >= '1996-01-03' AND fin <= '1996-01-05';
---------------------------------------------------------------------
	EJEMPLO ORDER BY ordernar desde un llamado de registro
SELECT * FROM pasajero
WHERE nombre ILIKE '_a%' 
ORDER BY (CASE nombre
	WHEN 'Daniela A'	THEN 7
    WHEN 'Latrena Hadwen'	THEN 2
	WHEN 'Lars Enticknap'	THEN 1
	WHEN 'Randene Gonsalvez'	THEN 3
	WHEN 'Hamid Govey'	THEN 5
	WHEN 'Tabina Lunck' 	THEN 6
	ELSE 100 END) ASC;
---------------------------------------------------------------------
		CLÁUSULA UNIONES

La cláusula/operador SQL UNION se utiliza para combinar los resultados de dos o más instrucciones SELECT sin devolver filas duplicadas.

Para utilizar esta cláusula UNION, cada instrucción SELECT debe tener

El mismo número de columnas seleccionadas
El mismo número de expresiones de columna
El mismo tipo de datos y
Tenerlos en el mismo orden
Pero no tienen que tener que estar en la misma longitud.

ESTA CONSULTA NO DEVUELVE FILAS DUPLICADAS

SELECT p.nombre, p.id, v.inicio, v.fin FROM pasajero AS p
LEFT JOIN viaje AS v
	ON v.id_pasajero = p.id

UNION

SELECT p.nombre, p.id, v.inicio, v.fin FROM pasajero AS p
RIGHT JOIN viaje AS v
	ON v.id_pasajero = p.id;

Clausula SQL UNION ALL: El operador UNION ALL se utiliza para combinar los resultados de dos instrucciones SELECT que incluyen filas duplicadas.
Cláusula SQL INTERSECT: se utiliza para combinar dos instrucciones SELECT, pero devuelve filas sólo de la primera instrucción SELECT que son idénticas a una fila de la segunda instrucción SELECT.
Cláusula SQL EXCEPT: Combina dos instrucciones SELECT y devuelve filas de la primera instrucción SELECT que no son devueltas por la segunda instrucción SELECT.

---------------------------------------------------------------------
			PL / PsSQL

Un bloque de codigo de ejecuta con DO luego el llamado de la funcion, 
los signos (pesos pesos) $$ se utilizan para abrir y cerrar funciones
#  DO $$

   $$

BEGIN; es donde empieza el codigo.
END; donde termina el codigo
DECLARE; es para declara variables, y el nombre de la variable va ir a la izquierda
		 luego va el tipo de valor, tambien podemos asignarle un valor de inicio con (:=)
		 ejempl: nombre_variable tipo_valor (:=iniciar_valor).

- Vamos hacer una notificacion en la barra de informacion de postgresql
que es un bloque de codigo.
DO $$
BEGIN
 RAISE NOTICE 'Algo esta pasando'
END
$$


- Vamos a agregar una variable que reciba las filas de una consulta
para mostrarlas en el NOTICE.

El tipo de dato que nos sirve para almacenar informacion de una fila es record.
DO $$
DECLARE
	rec record;
	contador integer := 0;
BEGIN
FOR rec IN SELECT * FROM pasajero LOOP
	RAISE NOTICE 'El pasajero llamado: %', rec.nombre;
	contador := contador + 1;
	END LOOP;
	RAISE NOTICE 'Conteo es %', contador;
END $$


----------------------------------
CREAR FUNCION PARA GUARDAR PL

para crear funciones tenemos que darle en CREATE FUNTION name_funcion()
luego le decimos que es lo que va a retornar con RETURNS y despues
le declaramos con AS $$ bloque de codigo $$ y antes de terminar todo
le indicamos que tipo de lenguaje usa con LANGUAGE PLPSQL;

CREATE FUNCTION importantePL()
 RETURNS void
AS $$
DECLARE
	rec record;
	contador INTEGER := 0;
BEGIN
FOR rec IN SELECT * FROM pasajero LOOP
	RAISE NOTICE 'El pasajero llamado: %', rec.nombre;
	contador := contador +1;
	END LOOP;
	RAISE NOTICE 'Conteo es: %', contador;
END $$
LANGUAGE PLPGSQL;

- llamado de funcion.
SELECT importantepl();